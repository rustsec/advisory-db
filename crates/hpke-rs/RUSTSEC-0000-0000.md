```toml
[advisory]
id = "RUSTSEC-0000-0000"
related = ["GHSA-g433-pq76-6cmf"]
package = "hpke-rs"
date = "2026-02-10"
url = "https://github.com/cryspen/hpke-rs/pull/118"
cvss = "CVSS:4.0/AV:N/AC:L/AT:P/PR:N/UI:N/VC:H/VI:H/VA:N/SC:H/SI:H/SA:N"
categories = ["crypto-failure"]
keywords = ["nonce-reuse", "integer-overflow", "hpke"]
references = ["https://datatracker.ietf.org/doc/rfc9180/"]

[versions]
patched = [">=0.6.0"]
```

# Nonce reuse via HPKE sequence number overflow

The hpke-rs library stores the HPKE encryption context sequence number as a `u32`, which has a maximum value of 2^32 - 1. RFC 9180 requires that the sequence number be checked against 2^(8*Nn) - 1, where Nn is the nonce length (12 bytes for all standard AEAD algorithms), yielding a maximum of 2^96 - 1.

The overflow guard in `increment_seq()` compares the `u32` sequence number (cast to `u128`) against 2^96 - 1. Since a `u32` can never reach this value, the comparison is always false and the check is dead code.

In debug builds, Rust's default overflow checking causes a panic when the counter wraps past 2^32 - 1. In release builds, the counter silently wraps to zero via `+=`, causing nonce reuse.

Nonce reuse in AES-GCM allows plaintext recovery and leaks the GHASH authentication key, enabling universal forgeries. Nonce reuse in ChaCha20-Poly1305 enables plaintext recovery via XOR of ciphertexts encrypted under the same nonce.

A fix was submitted via pull request but was not merged by the maintainer. The maintainer later copied the same fix and merged it independently, without providing credit or issuing a security advisory.
